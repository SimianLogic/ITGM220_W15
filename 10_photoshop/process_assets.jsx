//EXPORT OPTIONS (make a text layer called "options" with key:value pairs on each line)var export_full_size = true;var export_half_size = true;var full_size_postfix = "@2x";var half_size_postfix = "";var coordinates = "half";//half or fullvar origin = "top_left";var anchor = "top_left";var delimeter = "|";var item_delimeter = "||";var integers = true;var size_to_layer = true;var post_build_script = "";var root_width = false;//container is either app.activeDocument at the start//or a group (i.e. app.activeDocument.layerSets[0])function processAll(container){	var artLayers = container.artLayers.length;	for(var i = artLayers-1; i >= 0; i--)  //go in inverse depth order	{		processLayer(container.artLayers[i]);	}	var groups = container.layerSets.length;	for(var i = groups - 1; i >= 0; i--)	{    if(container.layerSets[i].name.indexOf("guide") != 0)    {      processAll(container.layerSets[i]);    }	}}var options = {};function getOptions(){	options = {};	var container = app.activeDocument;	var options_layer = null;	var artLayers = container.artLayers.length;	for(var i = artLayers-1; i >= 0; i--)  //go in inverse depth order	{		if(container.artLayers[i].name == "options")		{			options_layer = container.artLayers[i];		}	}	if(options_layer == null)	{		//using the defaults		return true;	}	if(options_layer.kind != LayerKind.TEXT)	{		alert("options must be a text layer!");		return false;	}	var raw_options_string = options_layer.textItem.contents;	var raw_options = raw_options_string.split('\r');	var op_length = raw_options.length;	for(var i=0; i < op_length; i++)	{		var key_val = raw_options[i].split(":");		switch(key_val[0])		{			case "export_full_size":				export_full_size = (key_val[1] == "true");				break;			case "export_half_size":				export_half_size = (key_val[1] == "true");				break;			case "full_size_postfix":				full_size_postfix = key_val[1];				break;			case "half_size_postfix":				half_size_postfix = key_val[1];				break;			case "origin":				origin = key_val[1];				break;			case "anchor":				anchor = key_val[1];				break;			case "delimeter":				delimeter = key_val[1];				break;			case "item_delimeter":				item_delimeter = key_val[1];				break;       case "coordinates":				coordinates = key_val[1];				break;      case "post_build_script":				coordinates = key_val[1];				break;			case "integers":				integers = (key_val[1] == "true");				break;			case "size_to_layer":				size_to_layer = (key_val[1] == "true");				break;			default:				alert("INVALID OPTION " + key_val[0]);				return false;		}	}	return true;}//comment this out to turn off logging!function trace(string){    // $.writeln (string);}function processLayer(layer){    var layerName = layer.name;	var docRef = app.activeDocument;    var revert_state = docRef.activeHistoryState;	if(layerName.indexOf("guide") == 0) return;	if(layerName == "options") return;	var x = parseInt((layer.bounds[0] + "").split(" ")[0]); //xyz px as a string => xyz	var y = parseInt((layer.bounds[1] + "").split(" ")[0]); //xyz px	var w = parseInt(((layer.bounds[2] - layer.bounds[0]) + "").split(" ")[0]); //xyz px	var h = parseInt(((layer.bounds[3] - layer.bounds[1]) + "").split(" ")[0]); //xyz px	var n = layer.name.split(" ").join("_");    var WIDTH  = parseInt((docRef.width  + "").split(" ")[0]); //xyz px    var HEIGHT = parseInt((docRef.height + "").split(" ")[0]); //xyz px	//first time through, throw out the document size	if(!root_width)	{		if(coordinates == "half")		{			if(integers)			{				metadata.push("root_width" + delimeter + "" + Math.round(WIDTH/2));				metadata.push("root_height" + delimeter + "" + Math.round(HEIGHT/2));			}else{				metadata.push("root_width" + delimeter + "" + WIDTH/2);				metadata.push("root_height" + delimeter + "" + HEIGHT/2);			}		}else{			metadata.push("root_width" + delimeter + "" + WIDTH);			metadata.push("root_height" + delimeter + "" + HEIGHT);		}		root_width = true;	}  var anchor_x = anchor.split("_")[1];  var anchor_y = anchor.split("_")[0];  var origin_x = origin.split("_")[1];  var origin_y = origin.split("_")[0];	var output_x = translateX(x,w,h,WIDTH,HEIGHT,coordinates=="half",anchor_x, origin_x);	var output_y = translateY(y,w,h,WIDTH,HEIGHT,coordinates=="half",anchor_y, origin_y);    trace("OUT: " + output_x + "," + output_y);	if(layer.kind == LayerKind.TEXT && layer.name.indexOf("text") == 0)	{		var text_color = layer.textItem.color.rgb.hexValue;		var text_font = layer.textItem.font;		var text_just = (layer.textItem.justification + "").split(".")[1].toLowerCase();		// alert("TEXT SIZE: " + layer.textItem.size);		var text_size = (layer.textItem.size + "").split(" ")[0];		var text = layer.textItem.contents;		if(text_just == "left") output_x 	= translateX(x,w,h,WIDTH,HEIGHT,coordinates=="half","left",origin_x);		if(text_just == "center") output_x 	= translateX(x,w,h,WIDTH,HEIGHT,coordinates=="half","center",origin_x);		if(text_just == "right") output_x 	= translateX(x,w,h,WIDTH,HEIGHT,coordinates=="half","right",origin_x);		if(integers)		{			metadata.push(n + delimeter + Math.round(output_x) + delimeter + Math.round(output_y) + delimeter + text_color + delimeter + text_font + delimeter + text_just + delimeter + Math.round(text_size) + delimeter + Math.round(w) + delimeter + Math.round(h) + delimeter + text);		}else{			metadata.push(n + delimeter + output_x + delimeter + output_y + delimeter + text_color + delimeter + text_font + delimeter + text_just + delimeter + text_size + delimeter + w + delimeter + h + delimeter + text);		}		return;	}	layer.visible = true;	if(integers)	{		metadata.push(n + delimeter + Math.round(output_x) + delimeter + Math.round(output_y));	}else{		metadata.push(n + delimeter + output_x + delimeter + output_y);	}	if(size_to_layer)	{		docRef.trim(TrimType.TRANSPARENT, true, true, true, true);	}	var safe_name = layerName.split(" ").join("_");	if(export_full_size) saveImage(safe_name + full_size_postfix);	if(export_half_size)	{		app.preferences.rulerUnits = Units.PERCENT;		app.activeDocument.resizeImage( 50,50 );		saveImage(safe_name + half_size_postfix);		app.preferences.rulerUnits = Units.PIXELS;	}    docRef.activeHistoryState = revert_state;    layer.visible = false;}function translateX(x, w, h, WIDTH, HEIGHT, halfsies, anchor_value, origin_value){	var return_x;	if(origin_value == "left")   //i.e. Unity, cocos2d	{		if(anchor_value == "left")		{			return_x = x;		}else if(anchor_value == "center"){			return_x = x + w/2;		}else if(anchor_value == "right"){			return_x = x + w;		}else{			trace("INVALID anchor_value: " + anchor_value);		}	}else if(origin_value == "center"){		if(anchor_value == "left")		{			return_x = x - WIDTH/2;		}else if(anchor_value == "center"){            var center_x = x + w/2;            return_x = x + w/2 - WIDTH/2;		}else if(anchor_value == "right"){			return_x = x - WIDTH/2 + w;		}else{			trace("INVALID anchor_value: " + anchor_value);		}	}else{		trace("INVALID origin_value: " + origin_value);	}    if(halfsies)    {        return_x = return_x / 2;    }	return return_x;}function translateY(y, w, h, WIDTH, HEIGHT, halfsies, anchor_value, origin_value){	var return_y;	//we assume that the origin_value is top_left (y-neg) and the origin_value is the top left	//the other options swap these on their head	if(origin_value == "bottom")   //i.e. Unity, cocos2d	{		if(anchor_value == "top")		{			return_y = HEIGHT - y;		}else if(anchor_value == "bottom"){			return_y = HEIGHT - y - h;		}else if(anchor_value == "center"){			return_y = HEIGHT - y - h/2;		}else{			trace("INVALID anchor_value: " + anchor_value);		}	}else if(origin_value == "top"){		if(anchor_value == "top")		{			return_y = y;		}else if(anchor_value == "bottom"){			return_y = h + y;		}else if(anchor_value == "center"){			return_y = y + w/2;		}else{			trace("INVALID anchor_value: " + anchor_value);		}	}else if(origin_value == "center"){		if(anchor_value == "top")		{			return_y = HEIGHT/2 - y;		}else if(anchor_value == "center"){            var center_y = y + h/2;            var inv_y = HEIGHT - center_y;            return_y = HEIGHT - (y + h/2) - HEIGHT/2;		}else if(anchor_value == "bottom"){			return_y = HEIGHT/2 - y - h;		}else{			trace("INVALID anchor_value: " + anchor_value);		}	}else{		trace("INVALID origin_value: " + origin_value);	}    if(halfsies)    {        return_y = return_y / 2;    }	return return_y;}function getTextSize(){	var ref = new ActionReference();	ref.putEnumerated( charIDToTypeID("Lyr "), charIDToTypeID("Ordn"), charIDToTypeID("Trgt") );	var desc = executeActionGet(ref).getObjectValue(stringIDToTypeID('textKey'));	var textSize =  desc.getList(stringIDToTypeID('textStyleRange')).getObjectValue(0).getObjectValue(stringIDToTypeID('textStyle')).getDouble (stringIDToTypeID('size'));	if (desc.hasKey(stringIDToTypeID('transform'))) {    	var mFactor = desc.getObjectValue(stringIDToTypeID('transform')).getUnitDoubleValue (stringIDToTypeID("yy") );    	textSize = (textSize* mFactor).toFixed(2);    }	return textSize;}function saveImage(layerName){	var Name = app.activeDocument.name.replace(/\.[^\.]+$/, '');	var Ext = decodeURI(app.activeDocument.name).replace(/^.*\./,'');	if(Ext.toLowerCase() != 'psd') return;	var Path = app.activeDocument.path;	var short_name = app.activeDocument.name.split(".")[0];	var saveFile = File(Path + "/" + short_name + "/" + layerName);	if(saveFile.exists) saveFile.remove();	SavePNG(saveFile);}function SavePNG(saveFile){    pngSaveOptions = new PNGSaveOptions();	activeDocument.saveAs(saveFile, pngSaveOptions, true, Extension.LOWERCASE);}function setAllVisible(container, visibility){	var artLayers = container.artLayers.length;	for(var i = 0; i < artLayers; i++)	{		container.artLayers[i].visible = visibility;	}	var groups = container.layerSets.length;	for(var i = groups - 1; i >= 0; i--)	{		setAllVisible(container.layerSets[i], visibility);	}}function setupExportDirectory(){	var short_name = app.activeDocument.name.split(".")[0];	var path = app.activeDocument.path;	var export_folder = new Folder(path + "/" + short_name);	if(export_folder.exists)	{		folderDelete(path + "/" + short_name);	}	export_folder.create();}function folderDelete(topLevel){	var folder = Folder(topLevel);	var files = folder.getFiles();	for(var f in files)	{		files[f].remove();	}	folder.remove();}var metadata;function writeMetadata(){	var path = app.activeDocument.path;	var short_name = app.activeDocument.name.split(".")[0];	var out = new File(path + "/" + short_name + "/metadata.txt");	out.open('w');	for(var i=0; i < metadata.length; i++)	{		out.write(metadata[i]);		if(i < metadata.length - 1)		{			out.write(item_delimeter);		}	}	out.close();}function main(){    var initial_units = app.preferences.rulerUnits;	app.preferences.rulerUnits = Units.PIXELS;	//bomb out if our options are malformed	if(!getOptions())	{		return;	}	var docRef = app.activeDocument    var initial_state = docRef.activeHistoryState;	var start_history = docRef.historyStates.length - 1;	docRef.crop(new Array(0,0,docRef.width, docRef.height));	metadata = [];	setupExportDirectory();	setAllVisible(app.activeDocument, false);	processAll(app.activeDocument);	writeMetadata();	setAllVisible(app.activeDocument, true);	docRef.activeHistoryState = initial_state;  app.preferences.rulerUnits = initial_units;  if(post_build_script != "")  {    var path = app.activeDocument.path;    var sh = app.system(post_build_script);  }  alert("Process complete");}main();